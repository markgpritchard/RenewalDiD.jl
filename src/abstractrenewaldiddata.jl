# data types used by `renewaldid`

"""
    AbstractRenewalDiDData{S, T, U}

Abstract type of containers for data passed to `renewaldid`.

Two subtypes are defined:
- `RenewalDiDData{S, T, U}`, for use with datasets
- `SimulationData{S, T, U, V}`, for use with simulated data
"""
abstract type AbstractRenewalDiDData{S, T, U} end

"""
    RenewalDiDData{S, T, U}

Container for data passed to `renewaldid`.

# Fields
- `observedcases::Matrix{S}`: matrix of observed cases, each group is a separate column
- `interventions::T`: array of intervention times. Time changes by row, group by column, and
    intervention in dimension 3 (see `InterventionMatrix` and `InterventionArray`) 
- `Ns::U`: population size of each group
- `exptdseedcases::Matrix{Float64}`: matrix of infections up to time `t=0` that seeds
    subsequent infection events
- `id::String`: dataset identification

# Constructors
    RenewalDiDData(; observedcases, interventions[, exptdseedcases, id, Ns, <keyword arguments>])

## Default values 
- `id=""`
- `exptdseedcases=nothing`, if not supplied is generated by the function `expectedseedcases`
- `Ns=nothing`, in which case the model assumes an unlimited population (or equivalently, 
    assessing changes in effective reproduction ratio rather than basic reproduction ratio)
- other keyword arguments are passed to the function `exptdseedcases` if 
    `isnothing(exptdseedcases)`

# Examples
```jldoctest
julia> using StableRNGs, Turing

julia> rng = StableRNG(10);

julia> observedcases = rand(rng, Poisson(10), 11, 3);  # 3 groups for times 0 to 10

julia> interventions = InterventionMatrix(10, 3, 7, nothing);

julia> Ns = 1000 .* ones(Int, 3);

julia> RenewalDiDData(; observedcases, interventions, Ns)
RenewalDiDData{Int64, InterventionMatrix{Int64}, Vector{Int64}}
 observedcases:  [10 8 15; 20 8 11; … ; 10 6 14; 9 9 8]
 interventions:  [0 0 0; 0 0 0; … ; 1 1 0; 1 1 0] {duration 10, starttimes [3, 7, nothing]}
 Ns:             [1000, 1000, 1000]
 exptdseedcases: [1.6236225474260566 1.4880770554298328 1.8607523407150066; \
    1.7226435732203347 1.587098081224111 1.9597733665092847; … ; 2.1187276763974463 \
    1.9831821844012225 2.3558574696863963; 2.217748702191724 2.0822032101955004 \
    2.454878495480674]
```
""" 
struct RenewalDiDData{S, T, U} <: AbstractRenewalDiDData{S, T, U}
    observedcases::Matrix{S}
    interventions::T
    Ns::U
    exptdseedcases::Matrix{Float64}
    id::String

    function RenewalDiDData(
        observedcases::Matrix{S}, 
        interventions::T, 
        Ns::Vector{<:Number}, 
        exptdseedcases::Matrix{<:Number},
        id::String=""
    ) where {S <:Number, T <:AbstractArray}
        _diddataassertions(observedcases, interventions, Ns, exptdseedcases)
        return new{S, T, Vector{Int}}(
            observedcases, 
            interventions, 
            convert.(Int, Ns), 
            convert.(Float64, exptdseedcases),
            id
        )
    end

    function RenewalDiDData(
        observedcases::Matrix{S}, 
        interventions::T, 
        ::Nothing, 
        exptdseedcases::Matrix{<:Number},
        id::String=""
    ) where {S <:Number, T <:AbstractArray}
        _diddataassertions(observedcases, interventions, exptdseedcases)
        return new{S, T, Nothing}(
            observedcases, 
            interventions, 
            nothing, 
            convert.(Float64, exptdseedcases),
            id
        )
    end
end

function RenewalDiDData( ; 
    observedcases, 
    interventions, 
    Ns=nothing,
    exptdseedcases=nothing,
    id="",
    kwargs...  # remaining keyword arguments are passed to `expectedseedcases`
)
    newexptdseedcases = _expectedseedcasesifneeded(exptdseedcases, observedcases; kwargs...)
    return RenewalDiDData(observedcases, interventions, Ns, newexptdseedcases, id)
end

## simulation data

"""
    SimulationData{S, T, U, V}

Container for simulated data passed to `renewaldid`.

Will generally be generated by the function `packsimulations`.

# Fields
- `observedcases::Matrix{S}: matrix of observed cases, each group is a separate column
- `interventions::T`: array of intervention times. Time changes by row, group by column, and intervention in        
    dimension 3 (see InterventionMatrix and InterventionArray)
- `Ns::U`: population size of each group
- `exptdseedcases::Matrix{Float64}`: matrix of infections up to time `t=0` that seeds
    subsequent infection events
- `rng::V`: random number generator used to generate the simulated data 
- `u0s::Vector{Vector{Int}}`: initial conditions used to generate the simulated data 
- `id::String`: dataset identification
""" 
struct SimulationData{S, T, U, V} <: AbstractRenewalDiDData{S, T, U}
    observedcases::Matrix{S}
    interventions::T
    Ns::U
    exptdseedcases::Matrix{Float64}
    rng::V
    u0s::Vector{Vector{Int}}
    id::String

    function SimulationData(
        observedcases::Matrix{S}, 
        interventions::T, 
        Ns::Vector{Int}, 
        exptdseedcases::Matrix{<:Number}, 
        rng::V, 
        u0s::Vector{Vector{Int}}, 
        id::String=""
    ) where {S <: Number, T <: AbstractArray, V <: AbstractRNG}
        _diddataassertions(observedcases, interventions, Ns, exptdseedcases)
        return new{S, T, Vector{Int}, V}(
            observedcases, 
            interventions, 
            Ns, 
            convert.(Float64, exptdseedcases),
            rng,
            u0s,
            id
        )
    end

    function SimulationData(
        observedcases::Matrix{S}, 
        interventions::T, 
        ::Nothing, 
        exptdseedcases::Matrix{<:Number}, 
        rng::V, 
        u0s::Vector{Vector{Int}}, 
        id::String=""
    ) where {S <: Number, T <: AbstractArray, V <: AbstractRNG}
        _diddataassertions(observedcases, interventions, exptdseedcases)
        return new{S, T, Nothing, V}(
            observedcases, 
            interventions, 
            nothing, 
            convert.(Float64, exptdseedcases),
            rng,
            u0s,
            id
        )
    end
end

function SimulationData( ; 
    observedcases, 
    interventions, 
    Ns, 
    rng, 
    u0s, 
    exptdseedcases=nothing,
    id="",
    kwargs...  # remaining keyword arguments are passed to `expectedseedcases`
)
    newexptdseedcases = _expectedseedcasesifneeded(exptdseedcases, observedcases; kwargs...)
    return SimulationData(observedcases, interventions, Ns, newexptdseedcases, rng, u0s, id)
end


# Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function _commonhash(x::AbstractRenewalDiDData, h)
    return hash(x.exptdseedcases, hash(x.Ns, hash(x.interventions, hash(x.observedcases, h))))
end

function _commonequals(a::AbstractRenewalDiDData, b::AbstractRenewalDiDData)
    a.observedcases == b.observedcases || return false  # cannot be missing 
    a.Ns == b.Ns || return false  # cannot be missing 
    a.exptdseedcases == b.exptdseedcases || return false  # cannot be missing 
    a.id == b.id || return false  # cannot be missing 
    # at this point, all of the above are true, so 
    return a.interventions == b.interventions
end

Base.hash(x::RenewalDiDData, h::UInt64) = hash(x.id, _commonhash(x, hash(:RenewalDiDData, h)))
Base.:(==)(a::RenewalDiDData, b::RenewalDiDData) = _commonequals(a, b)

function Base.hash(x::SimulationData, h::UInt64)
    return hash(x.id, hash(x.u0s, hash(x.rng, _commonhash(x, hash(:SimulationData, h)))))
end

function Base.:(==)(a::SimulationData, b::SimulationData)
    a.rng == b.rng || return false  # cannot be missing 
    a.u0s == b.u0s || return false  # cannot be missing 
    # at this point, all of the above are true, so 
    return _commonequals(a, b)
end

function Base.show(io::IO, ::MIME"text/plain", d::AbstractRenewalDiDData)
    return _showabstractrenewaldiddata(io, d)
end

function _showabstractrenewaldiddata(io, d)
    _showtitle(io, d)
    print(io, "\n observedcases:  ")
    show(io, _observedcases(d))
    print(io, "\n interventions:  ")
    show(io, _interventions(d))
    print(io, "\n Ns:             ")
    _showns(io, d)
    print(io, "\n exptdseedcases: ")
    show(io, _expectedseedcases(d))
    return nothing
end

function _showtitle(io, d::RenewalDiDData{S, T, U}) where {S, T, U}
    print(io, "RenewalDiDData{$S, $T, $U}$(_printid(d))")
    return nothing
end

function _showtitle(io, d::SimulationData{S, T, U}) where {S, T, U}
    print(io, "SimulationData{$S, $T, $U}$(_printid(d))")
    return nothing
end

_printid(d) = _id(d) == "" ? "" : ", ($(_id(d)))"
_showns(io, d::AbstractRenewalDiDData{<:Any, <:Any, Vector{Int}}) = show(io, _ns(d))
_showns(io, ::AbstractRenewalDiDData{<:Any, <:Any, Nothing}) = print(io, "unlimited")

## extract values from structs 

_expectedseedcases(d::AbstractRenewalDiDData) = d.exptdseedcases 
_id(d::AbstractRenewalDiDData) = d.id
_interventions(d::AbstractRenewalDiDData) = d.interventions 
_ngroups(d::AbstractRenewalDiDData) = _ngroups(_interventions(d))
_ninterventions(d::AbstractRenewalDiDData) = _ninterventions(_interventions(d))
_ns(d::AbstractRenewalDiDData) = d.Ns 
_nseeds(d::AbstractRenewalDiDData) = size(_expectedseedcases(d), 1)
_ntimes(d::AbstractRenewalDiDData) = _ntimes(_interventions(d))
_observedcases(d::AbstractRenewalDiDData) = d.observedcases 
